import streamlit as st
import pandas as pd
import numpy as np
import joblib
import json
import plotly.express as px
import plotly.graph_objects as go
import plotly.io as pio
import streamlit.components.v1 as components
from pathlib import Path

try:
    import geopandas as gpd
    GEOPANDAS_AVAILABLE = True
except ImportError:
    GEOPANDAS_AVAILABLE = False

# --------------------------------------------------
# Page config
# --------------------------------------------------
st.set_page_config(
    page_title="Norovirus Outbreak Prediction Dashboard",
    layout="wide"
)

# --------------------------------------------------
# Paths
# --------------------------------------------------
MODEL_PATH = Path("models/lightgbm_model_20260204_154643.pkl")
PARAMS_PATH = Path("models/lightgbm_model_20260204_154643_params.json")
THRESHOLD_PATH = Path("models/threshold.json")
TEST_DATA_PATH = Path("Testing.csv")
OUTPUT_PATH = Path("norovirus_predictions.csv")

# --------------------------------------------------
# Load model & threshold
# --------------------------------------------------
@st.cache_resource
def load_model():
    if not MODEL_PATH.exists():
        st.error("Model file not found: models/lightgbm_model_20260204_154643.pkl")
        st.stop()
    loaded = joblib.load(MODEL_PATH)
    if isinstance(loaded, dict):
        # Handle common training artifacts where the model is stored in a dict
        for key in ("model", "estimator", "clf", "classifier", "lightgbm_model"):
            if key in loaded:
                return loaded[key]
        st.error(
            "Model file contains a dict but no known model key. "
            f"Available keys: {list(loaded.keys())}"
        )
        st.stop()
    return loaded

@st.cache_resource
def load_params():
    if not PARAMS_PATH.exists():
        st.error("Params file not found: models/lightgbm_model_20260204_154643_params.json")
        st.stop()
    with open(PARAMS_PATH, "r") as f:
        return json.load(f)

@st.cache_resource
def load_threshold():
    if not THRESHOLD_PATH.exists():
        st.error("Threshold file not found: models/threshold.json")
        st.stop()
    with open(THRESHOLD_PATH, "r") as f:
        return json.load(f)["threshold"]

model = load_model()
params = load_params()
default_threshold = load_threshold()

# --------------------------------------------------
# Prediction helper
# --------------------------------------------------
def predict_positive_proba(model_obj, features):
    if hasattr(model_obj, "predict_proba"):
        proba = model_obj.predict_proba(features)
        if isinstance(proba, np.ndarray) and proba.ndim == 2 and proba.shape[1] >= 2:
            return proba[:, 1]
        return np.asarray(proba).ravel()
    if hasattr(model_obj, "predict"):
        preds = model_obj.predict(features)
        return np.asarray(preds).ravel()
    raise AttributeError("Model object has no predict or predict_proba method")

# --------------------------------------------------
# Sidebar navigation
# --------------------------------------------------
st.sidebar.title("Navigation")
page = st.sidebar.radio(
    "Go to",
    ["About Data", "Run Model", "Results"]
)

# --------------------------------------------------
# Global session storage
# --------------------------------------------------
if "results_df" not in st.session_state:
    st.session_state["results_df"] = None

# ==================================================
# PAGE 1: ABOUT DATA
# ==================================================
if page == "About Data":

    st.title("Norovirus Outbreak Modeling Framework")

    about_tabs = st.tabs(["Overview", "Input Features", "Global oyster harvesting areas"])

    with about_tabs[0]:
        st.markdown("""
        ## Objective
        Predict the **probability of norovirus outbreaks (0‚Äì1)** using
        hydro-meteorological and location indicators.

        ## Data Sources
        - **Hydrology**: [USGS](https://apps.usgs.gov/nwismapper/) (gage height, Salinity)
        - **Meteorology**: [NOAA](https://tidesandcurrents.noaa.gov/), [NASA POWER](https://power.larc.nasa.gov/data-access-viewer/) (TMAX, TMIN, precipitation, solar radiation)
        - **Spatial**: Latitude & Longitude

        ### Additional Data Sources
        - **Salinity**: [CDMO](https://cdmo.baruch.sc.edu/dges/), [Canada Open Data](https://open.canada.ca/data/en/dataset/719955f2-bf8e-44f7-bc26-6bd623e82884), [Marine In Situ](https://marineinsitu.eu/dashboard/)
        - **Precipitation**: [LSU AgCenter](https://weather.lsuagcenter.com/), [Pacific Climate Data Portal](https://services.pacificclimate.org/met-data-portal-pcds/app/#close)
        - **Gage Height**: [Canadian Water Office](https://wateroffice.ec.gc.ca/), [SHOM Data](https://data.shom.fr/)
        - **Sea Surface Temperature**: [Climate Weather Canada](https://climate.weather.gc.ca/), [Geographic.org](https://geographic.org/)

        ## Target Variable
        - Binary outbreak indicator  
        - `1` = confirmed outbreak  
        - `0` = no outbreak  

        ## Model
        - LightGBM classifier
        - Hyperparameters optimized using particle swarm optimization (PSO)
        - Outputs calibrated probability ‚àà [0, 1]

        ## Decision Rule
        - Outbreak confirmed if  
          **Probability ‚â• Threshold**
        """)

        st.info("This page is static and intended for documentation.")

        # Study Area Shapefiles
        st.subheader("üó∫Ô∏è Study Area Maps")
        st.markdown("Click on each region to view and download the study area map:")
        
        study_areas = {
            "BC (British Columbia)": Path("BC.tif"),
            "LA (Gulf of Mexico)": Path("LA.tif"),
            "FR (Southeast France Coast)": Path("FR.tif"),
            "WA (Washington Coast)": Path("WA.tif")
        }
        
        col1, col2 = st.columns(2)
        
        for idx, (name, tif_path) in enumerate(study_areas.items()):
            col = col1 if idx % 2 == 0 else col2
            with col:
                with st.expander(f"üìç {name}"):
                    if tif_path.exists():
                        try:
                            from PIL import Image
                            img = Image.open(tif_path)
                            st.image(img, caption=name, use_container_width=True)
                            
                            with open(tif_path, "rb") as f:
                                st.download_button(
                                    label=f"Download {tif_path.name}",
                                    data=f.read(),
                                    file_name=tif_path.name,
                                    mime="image/tiff",
                                    key=f"download_{tif_path.stem}"
                                )
                        except ImportError:
                            st.error("PIL/Pillow library required. Install with: pip install Pillow")
                        except Exception as e:
                            st.error(f"Error loading image: {e}")
                            with open(tif_path, "rb") as f:
                                st.download_button(
                                    label=f"Download {tif_path.name}",
                                    data=f.read(),
                                    file_name=tif_path.name,
                                    mime="image/tiff",
                                    key=f"download_{tif_path.stem}"
                                )
                    else:
                        st.warning(f"{name} not found")

        # LightGBM PSO Code
        st.subheader("üíª Model Code")
        code_path = Path("lightgbm_PSO.txt")
        if code_path.exists():
            with open(code_path, "r", encoding="utf-8") as f:
                code_content = f.read()
            with st.expander("Click to view LightGBM PSO Code"):
                st.code(code_content, language="python")
        else:
            st.warning(f"Code file not found: {code_path}")

    with about_tabs[1]:
        st.subheader("Input Features")
        
        st.markdown("""
        ## Main Variables
        - Solar Radiation
        - Sea Surface Temperature
        - Gage Height
        - Precipitation
        - Salinity
        - Latitude
        - Longitude
        
        ---
        
        ## Derived Input Features
        
        ### Solar Radiation
        - **SR1**: Total mean solar radiation from 4‚Äì29 days prior to outbreak
        - **SR2**: Mean solar radiation from 14‚Äì30 days prior to outbreak
        
        ### Temperature
        - **T1**: Mean maximum temperature from 14‚Äì30 days prior to outbreak
        - **T2**: Mean average temperature from 14‚Äì21 days prior to outbreak
        - **T3**: Temperature fluctuation 2 days prior to outbreak
        - **T4**: Average water temperature 30 days prior to outbreak
        
        ### Gage Height
        - **GH1**: Total mean gage height from 4‚Äì30 days prior to outbreak
        - **GH2**: Average gage height 2 days prior to outbreak
        - **GH3**: Gage height variation 17 days prior to outbreak
        - **GH4**: Minimum gage height difference between 11 and 12 days prior to outbreak
        
        ### Rainfall
        - **R1**: Total rainfall from 4‚Äì9 days prior to outbreak
        - **R2**: Cumulative rainfall in 10 days prior to outbreak
        
        ### Salinity
        - **S1**: Total daily average salinity from 4‚Äì29 days prior to outbreak
        - **S2**: Daily average salinity 30 days prior to outbreak
        
        ### Location
        - **Latitude**
        - **Longitude**
        """)

    with about_tabs[2]:
        st.subheader("Global oyster harvesting areas")
        st.markdown("This map auto-discovers all .shp files in this folder and displays them as harvesting areas.")
        st.markdown(
            "Washington areas: https://fortress.wa.gov/doh/oswpviewer/index.html"
        )
        st.markdown(
            "Louisiana areas: https://ladhh.maps.arcgis.com/apps/webappviewer/index.html?id=a5577e62649d4242aeca3c2083280e5a"
        )
        st.markdown(
            "British Columbia areas: https://egisp.dfo-mpo.gc.ca/vertigisstudio/web/?app=84572c5703a24d0cbe062d2d7ba126d7&locale=en"
        )
        st.markdown(
            "Texas areas: https://tpwd.maps.arcgis.com/apps/webappviewer/index.html?id=d5e366e86a894a6cbe06ad70e9befd95"
        )
        st.markdown(
            "Florida areas: https://experience.arcgis.com/experience/00ad5ac144a9437ea94a6a809bbe9ef7/"
        )
        st.markdown(
            "Global Oyster Atlas: https://symbio6.nl/en/apps/oyster-map.html"
        )
        st.markdown(
            "Maryland areas: https://symbio6.nl/en/apps/oyster-map.html"
        )

# ==================================================
# PAGE 2: RUN MODEL
# ==================================================
elif page == "Run Model":

    st.title("Run Norovirus Outbreak Prediction")

    if not TEST_DATA_PATH.exists():
        st.error("Testing data not found: Testing.csv")
        st.stop()

    threshold = st.slider(
        "Outbreak Probability Threshold",
        min_value=0.0,
        max_value=1.0,
        value=float(default_threshold),
        step=0.01
    )

    df = pd.read_csv(TEST_DATA_PATH)

    st.subheader("Testing Data Preview")
    st.dataframe(df.head())

    if st.button("Run Prediction"):
        features_df = df.copy()
   
        drop_cols = []
        if "Date" in features_df.columns:
            # LightGBM expects numeric features; drop Date for prediction.
            features_df["Date"] = pd.to_datetime(features_df["Date"], errors="coerce")
            drop_cols.append("Date")
        if "ID" in features_df.columns:
            drop_cols.append("ID")
        if drop_cols:
            features_df = features_df.drop(columns=drop_cols)

        # Select only the features used in training
        feature_names = params.get("feature_names", [])
        if feature_names:
            features_df = features_df[feature_names]

        # Convert categorical features to category dtype
        categorical_features = params.get("categorical_features", [])
        for col in categorical_features:
            if col in features_df.columns:
                features_df[col] = features_df[col].astype('category')

        try:
            probs = predict_positive_proba(model, features_df)
        except Exception as e:
            st.error(f"Model prediction failed: {e}")
            st.stop()

        df["Outbreak_Probability"] = probs
        df["Outbreak_Flag"] = (probs >= threshold).astype(int)

        df.to_csv(OUTPUT_PATH, index=False)
        st.session_state["results_df"] = df

        st.success(f"Prediction completed. Output saved to {OUTPUT_PATH}.")

# ==================================================
# PAGE 3: RESULTS & VISUALIZATION
# ==================================================
elif page == "Results":

    st.title("Prediction Results & Visualization")

    if st.session_state["results_df"] is None:
        st.warning("No results available. Run the model first.")
        st.stop()

    df = st.session_state["results_df"]

    # Filters
    if "Region" in df.columns:
        st.subheader("Filter by Region")
        region_options = sorted(df["Region"].dropna().unique().tolist())
        selected_region = st.selectbox("Select Region", ["All"] + region_options)
        if selected_region != "All":
            df_filtered = df[df["Region"] == selected_region].copy()
        else:
            df_filtered = df.copy()
    else:
        selected_region = "All"  # Default to "All" if Region column doesn't exist
        df_filtered = df.copy()

    if "ID" in df_filtered.columns:
        st.subheader("Filter by Event (ID)")
        id_options = sorted(df_filtered["ID"].dropna().unique().tolist())
        selected_id = st.selectbox("Event ID", ["All"] + id_options)
        if selected_id != "All":
            df_view = df_filtered[df_filtered["ID"] == selected_id].copy()
        else:
            df_view = df_filtered.copy()
    else:
        df_view = df_filtered.copy()

    st.subheader("Prediction Output (Preview)")
    st.dataframe(df_view.head())

    manual_date = None
    min_date = None
    max_date = None
    if "Date" in df_view.columns:
        date_series = pd.to_datetime(df_view["Date"], errors="coerce").dt.date
        valid_dates = date_series.dropna()
        if not valid_dates.empty:
            min_date = valid_dates.min()
            max_date = valid_dates.max()
            manual_date = st.date_input(
                "Select Date",
                value=min_date,
                min_value=min_date,
                max_value=max_date,
                key="manual_date"
            )

    if "sim_playing" not in st.session_state:
        st.session_state["sim_playing"] = False

    # -------------------------------
    # Common Animation Controls
    # -------------------------------
    st.markdown("""
    <style>
    div[data-testid="stHorizontalBlock"] button {
        font-weight: bold !important;
        color: black !important;
        background-color: white !important;
        border: 2px solid black !important;
    }
    </style>
    """, unsafe_allow_html=True)
    
    control_cols = st.columns(2)
    with control_cols[0]:
        if st.button("‚ñ∂ Start Animation", key="start_btn_common"):
            st.session_state["sim_playing"] = True
            st.rerun()
    with control_cols[1]:
        if st.button("‚è∏ Pause Animation", key="pause_btn_common"):
            st.session_state["sim_playing"] = False
            st.rerun()

    # -------------------------------
    # Time series (if Date exists)
    # -------------------------------
    if "Date" in df_view.columns:
        st.subheader("Temporal Outbreak Risk")

        temporal_df = df_view.copy()
        temporal_df["Date"] = pd.to_datetime(temporal_df["Date"])
        temporal_df = temporal_df.sort_values("Date")
        temporal_df["Date_Frame"] = temporal_df["Date"].dt.strftime("%m/%d/%Y")
        temporal_df["Date_Only"] = temporal_df["Date"].dt.date
        temporal_df["Outbreak_Status_Label"] = np.where(
            temporal_df["Outbreak_Flag"] == 1,
            "Outbreak",
            "No Outbreak"
        )
        temporal_df["Outbreak_Probability_Label"] = temporal_df["Outbreak_Probability"].map(
            lambda v: f"{v:.2f}"
        )
        temporal_df["Temporal_Label"] = (
            temporal_df["Outbreak_Probability_Label"]
            + " | "
            + temporal_df["Outbreak_Status_Label"]
        )

        line_trace = go.Scatter(
            x=temporal_df["Date"],
            y=temporal_df["Outbreak_Probability"],
            mode="lines+markers",
            line=dict(color="#1f77b4"),
            marker=dict(symbol="star", size=8, color="#1f77b4"),
            name="Predicted Outbreak Risk"
        )

        if manual_date and manual_date in temporal_df["Date_Only"].values:
            first_row = temporal_df[temporal_df["Date_Only"] == manual_date].iloc[0]
        else:
            first_row = temporal_df.iloc[0]
        marker_trace = go.Scatter(
            x=[first_row["Date"]],
            y=[first_row["Outbreak_Probability"]],
            mode="markers+text",
            text=[first_row["Temporal_Label"]],
            textposition="top center",
            textfont=dict(color="black", size=12, family="Arial Black"),
            marker=dict(size=12, color="red"),
            hovertemplate="Probability: %{y:.2f}<br>Status: %{text}<extra></extra>",
            showlegend=False
        )

        threshold_trace = go.Scatter(
            x=[temporal_df["Date"].min(), temporal_df["Date"].max()],
            y=[default_threshold, default_threshold],
            mode="lines",
            line=dict(color="black", dash="dash", width=2),
            name=f"Threshold ({default_threshold:.2f})",
            showlegend=True
        )

        fig2 = go.Figure(data=[line_trace, marker_trace, threshold_trace])

        frames = []
        for _, row in temporal_df.iterrows():
            frames.append(
                go.Frame(
                    data=[
                        go.Scatter(
                            x=[row["Date"]],
                            y=[row["Outbreak_Probability"]],
                            mode="markers+text",
                            text=[row["Temporal_Label"]],
                            textposition="top center",
                            textfont=dict(color="black", size=12, family="Arial Black"),
                            marker=dict(size=12, color="red")
                        )
                    ],
                    name=row["Date_Frame"],
                    traces=[1]
                )
            )

        fig2.frames = frames

        fig2.update_layout(
            title=dict(text="Temporal Norovirus Outbreak Probability", font=dict(color="black", size=18, family="Arial Black")),
            showlegend=True,
            legend=dict(x=0.02, y=0.98, xanchor="left", yanchor="top", font=dict(color="black", size=14, family="Arial")),
            plot_bgcolor="white",
            paper_bgcolor="white",
            xaxis=dict(
                title=dict(text="Date", font=dict(size=16, family="Arial Black", color="black")),
                tickfont=dict(size=14, family="Arial", color="black"),
                tickformat="%m/%d/%Y",
                gridcolor="lightgray",
                showline=True,
                linecolor="black"
            ),
            yaxis=dict(
                title=dict(text="Outbreak Probability", font=dict(size=16, family="Arial Black", color="black")),
                tickfont=dict(size=14, family="Arial", color="black"),
                gridcolor="lightgray",
                showline=True,
                linecolor="black"
            ),
            updatemenus=[
                {
                    "type": "buttons",
                    "showactive": False,
                    "x": 0.02,
                    "y": 1.05,
                    "xanchor": "left",
                    "yanchor": "top",
                    "direction": "left",
                    "font": {"color": "black", "size": 12},
                    "buttons": [
                        {
                            "label": "Play",
                            "method": "animate",
                            "args": [None, {"frame": {"duration": 700, "redraw": True}, "fromcurrent": True}]
                        },
                        {
                            "label": "Pause",
                            "method": "animate",
                            "args": [[None], {"frame": {"duration": 0, "redraw": True}, "mode": "immediate"}]
                        }
                    ],
                }
            ],
            sliders=[
                {
                    "x": 0.1,
                    "y": -0.15,
                    "len": 0.8,
                    "pad": {"t": 30, "b": 10},
                    "currentvalue": {
                        "prefix": "Date: ",
                        "font": {"size": 14, "family": "Arial", "color": "black"}
                    },
                    "font": {"color": "black"},
                    "steps": [
                        {
                            "label": frame.name,
                            "method": "animate",
                            "args": [[frame.name], {"frame": {"duration": 0, "redraw": True}, "mode": "immediate"}]
                        }
                        for frame in frames
                    ],
                }
            ]
        )

        if st.session_state.get("sim_playing"):
            html = pio.to_html(fig2, include_plotlyjs="cdn", full_html=False, auto_play=True)
            components.html(html, height=520)
        else:
            st.plotly_chart(fig2, use_container_width=True)

    # -------------------------------
    # Spatial visualization (if lat/lon exists)
    # -------------------------------
    if {"Lat", "Long"}.issubset(df_view.columns):
        st.subheader("Spatial Outbreak Risk")
        
        open_fullscreen = st.button("Open Full Screen Map")

        df_view = df_view.copy()
        df_view["Outbreak_Status_Label"] = np.where(
            df_view["Outbreak_Flag"] == 1,
            "Outbreak",
            "No Outbreak"
        )
        df_view["Outbreak_Probability_Label"] = df_view["Outbreak_Probability"].map(
            lambda v: f"{v:.2f}"
        )
        df_view["Outbreak_Map_Label"] = (
            df_view["Outbreak_Probability_Label"]
            + "\n"
            + df_view["Outbreak_Status_Label"]
        )

        # Prepare data for animation if Date exists
        if "Date" in df_view.columns:
            df_view["Date"] = pd.to_datetime(df_view["Date"])
            df_view = df_view.sort_values("Date")  # Sort by date chronologically
            df_view["Date_Frame"] = df_view["Date"].dt.strftime("%m/%d/%Y")
            frame_values = df_view["Date_Frame"].dropna().unique().tolist()  # Already sorted
        else:
            frame_values = []

        center_lat = float(df_view["Lat"].mean()) if not df_view["Lat"].isna().all() else 0.0
        center_lon = float(df_view["Long"].mean()) if not df_view["Long"].isna().all() else 0.0



        def create_rectangle_coords(lat, lon, delta=0.3):
            """Create rectangle coordinates for ¬±delta degrees around a point."""
            # Create rectangle: bottom-left -> bottom-right -> top-right -> top-left -> close
            lats = [lat - delta, lat - delta, lat + delta, lat + delta, lat - delta]
            lons = [lon - delta, lon + delta, lon + delta, lon - delta, lon - delta]
            return lats, lons

        def get_color_from_probability(prob):
            """Map probability to color gradient (0=green, 1=dark red)."""
            # Green (0) -> Yellow (0.5) -> Red (1.0)
            if prob < 0.5:
                # Interpolate green to yellow
                r = int(255 * (prob * 2))
                g = 255
                b = 0
            else:
                # Interpolate yellow to dark red
                r = 255
                g = int(255 * (2 - 2 * prob))
                b = 0
            return f"rgb({r},{g},{b})"



        def build_traces(frame_df):
            traces = []
            
            # Handle all regions uniformly with rectangles
            for idx, row in frame_df.iterrows():
                lat, lon = row["Lat"], row["Long"]
                prob = row["Outbreak_Probability"]
                
                # Create rectangle coordinates
                rect_lats, rect_lons = create_rectangle_coords(lat, lon, delta=0.3)
                
                # Get color based on probability
                color = get_color_from_probability(prob)
                
                # Create rectangle trace
                rect_trace = go.Scattermapbox(
                    lat=rect_lats,
                    lon=rect_lons,
                    mode="lines",
                    fill="toself",
                    fillcolor=color,
                    opacity=0.6,
                    line=dict(color=color, width=2),
                    customdata=[[
                        row["Outbreak_Probability_Label"],
                        row["Outbreak_Status_Label"],
                        row["Date_Frame"],
                        row["Outbreak_Map_Label"]
                    ]] * len(rect_lats),
                    hovertemplate=(
                        "Area: %{customdata[3]}<br>"
                        "Date: %{customdata[2]}<br>"
                        "Probability: %{customdata[0]}<br>"
                        "Status: %{customdata[1]}<extra></extra>"
                    ),
                    showlegend=False
                )
                traces.append(rect_trace)
                
                # Add text label at the center of the rectangle showing the probability
                text_trace = go.Scattermapbox(
                    lat=[lat],
                    lon=[lon],
                    mode="text",
                    text=[f"{prob:.2f}"],
                    textposition="middle center",
                    textfont=dict(
                        size=14,
                        color="black",
                        family="Arial Black"
                    ),
                    showlegend=False,
                    hoverinfo="skip"
                )
                traces.append(text_trace)
            
            return traces

        if frame_values:
            if manual_date:
                manual_frame = manual_date.strftime("%Y-%m-%d")
            else:
                manual_frame = None
            if manual_frame in frame_values:
                initial_df = df_view[df_view["Date_Frame"] == manual_frame]
            else:
                initial_df = df_view[df_view["Date_Frame"] == frame_values[0]]
        else:
            initial_df = df_view

        initial_traces = build_traces(initial_df)
        fig4 = go.Figure(data=initial_traces)

        if frame_values:
            frames = []
            # Calculate average risk for each frame for display
            frame_risk_map = {}
            for frame_value in frame_values:
                frame_df = df_view[df_view["Date_Frame"] == frame_value]
                avg_risk = frame_df["Outbreak_Probability"].mean()
                frame_risk_map[frame_value] = avg_risk
                frame_traces = build_traces(frame_df)
                frames.append(go.Frame(data=frame_traces, name=frame_value))
            fig4.frames = frames

            fig4.update_layout(
                updatemenus=[
                    {
                        "type": "buttons",
                        "showactive": False,
                        "x": 0.02,
                        "y": 0.02,
                        "xanchor": "left",
                        "yanchor": "bottom",
                        "direction": "left",
                        "buttons": [
                            {
                                "label": "Play",
                                "method": "animate",
                                "args": [None, {"frame": {"duration": 700, "redraw": True}, "fromcurrent": True}]
                            },
                            {
                                "label": "Pause",
                                "method": "animate",
                                "args": [[None], {"frame": {"duration": 0, "redraw": True}, "mode": "immediate"}]
                            }
                        ],
                    }
                ],
                sliders=[
                    {
                        "x": 0.1,
                        "y": 0.02,
                        "len": 0.8,
                        "pad": {"t": 30, "b": 10},
                        "currentvalue": {"prefix": "Date: | Risk: "},
                        "steps": [
                            {
                                "label": f"{frame_value} | Risk: {frame_risk_map[frame_value]:.2f}",
                                "method": "animate",
                                "args": [[frame_value], {"frame": {"duration": 0, "redraw": True}, "mode": "immediate"}]
                            }
                            for frame_value in frame_values
                        ],
                    }
                ]
            )

        # Configure mapbox layout with satellite imagery
        mapbox_dict = dict(
            style="open-street-map",  # More colorful, realistic map style
            zoom=3,
            center={"lat": center_lat, "lon": center_lon}
        )
        
        # Add invisible scatter trace for colorbar legend
        legend_trace = go.Scattermapbox(
            lat=[None],
            lon=[None],
            mode="markers",
            marker=dict(
                size=1,
                color=[0, 0.5, 1],  # Dummy values for colorscale
                colorscale=[[0, "rgb(0,255,0)"], [0.5, "rgb(255,255,0)"], [1, "rgb(255,0,0)"]],
                showscale=True,
                colorbar=dict(
                    title="Outbreak<br>Probability",
                    thickness=15,
                    len=0.7,
                    x=1.02,
                    xanchor="left",
                    tickvals=[0, 0.25, 0.5, 0.75, 1.0],
                    ticktext=["0%", "25%", "50%", "75%", "100%"]
                )
            ),
            showlegend=False
        )
        fig4.add_trace(legend_trace)
        
        fig4.update_layout(
            title="Spatial Outbreak Risk Simulation",
            showlegend=False,
            mapbox=mapbox_dict,
            margin=dict(l=0, r=0, t=40, b=0)
        )

        full_screen_html = pio.to_html(
            fig4,
            include_plotlyjs="cdn",
            full_html=False,
            auto_play=st.session_state.get("sim_playing")
        )

        if open_fullscreen:
            # Create complete HTML for popup window
            complete_html = pio.to_html(
                fig4,
                include_plotlyjs="cdn",
                full_html=True,
                auto_play=st.session_state.get("sim_playing")
            )
            payload = json.dumps(complete_html)
            components.html(
                f"""
                <script>
                const html = {payload};
                const win = window.open('', '_blank');
                if (win) {{
                    win.document.write(html);
                    win.document.close();
                }}
                </script>
                """,
                height=0
            )

        if st.session_state.get("sim_playing"):
            components.html(full_screen_html, height=620)
        else:
            st.plotly_chart(
                fig4,
                use_container_width=True,
                config={"displaylogo": False, "displayModeBar": True}
            )

    # -------------------------------
    # Download results
    # -------------------------------
    st.subheader("Download Results")

    csv = df.to_csv(index=False).encode("utf-8")
    st.download_button(
        label="Download Prediction Results (CSV)",
        data=csv,
        file_name="norovirus_predictions.csv",
        mime="text/csv"
    )
